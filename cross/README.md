# Cross-Compiling
## Part 1 - The Build Process 
This is the standard GNU build method of using autotools and make. The developers and maintainers of the libraries are going to use autotools (autoconf, automake) to create the necessary config files for the library's users (you and me) to configure and build the software.

You can think of the build process as three commands: `./config`, `make`, `make install`.

1. Configure
   - The system prepares for the build process. 
   - There will be a shell script that we execute to configure the build enviroment.
   - This is where to specifiy all the build and compile options for the library being built.
   - This is a very important step in cross-compiling.
2. Make
   - All of the source files are compiled into object files and linked into the final binaries (executables, shared objects or both)
   - The Makefiles, generated by the config script, will call the compiler and linker as necessary.
3. Install
   - The target files are all copied the a specified install directory.
   - Target files are the compiled binaries, header files, shared objects, documentation, etc.

### Configuration Phase
Here we specify all options for the build process. This includes
- Specify cross-compiler to be used 
  - this is so the default system compiler isn't used instead.
  - done via command-line option, command-line argument, or enviroment variable
- Specify the path to any include files
  - usually C header files `.h`
  - Defines library API (i.e. data/functions) for your application
- Specify the path to any shared libraries
  - Needed if the lib `.so` being built links into another lib.
  - done via command-line option, command-line argument, or enviroment variable
  - are "parallel" to the header files.
- Specify the installation directory 
  - if the install dir is not specified the installation will be install on the host system.
  - Useful when creating a root file system that would eventually go onto an embedded device.
  - Useful when creating a cross-comping development enviroment.

When it comes to using command-line option, command-line argument, or enviroment variable to specify some value the command-line option is always the prefered method.

#### Other Configuration Options
There are config steps you may need to take depending on your use case.
- Pass in environment variables for preprocessing, compiling, and linking
- `CPPFLAGS` used for the C++ preprocessor usually for included dirs
- `LDFLAGS` used for the linker usually locations of shared objects
- `LDLIBS` used to specify the name of the actual library you trying to link into

It's important to know, every single library you compile will be different. Read the documentation!!

### Make Phase
Builds/compiles the library. Generally only the `make` command is need. Sometimes you need to pass variables to `make` to get things to compile properly. E.g the variable is one that is not inlcluded as part of the configuration.

### Install Phase
Copies all target files, a.k.a. distribution files, to specified install directory. Intermediate build files will not be copy. Be careful when using `sudo` during this phase. Often the OS will prevent you from doing damage during the install phase, but using `sudo` will override this. It's recommended to build in a virtual enviroment to prevent breaking your host system. 

Technically the install is not a separate command, it's part of the `make` command as a phony target.


## Part 2 - Demonstration
In this demo we'll be cross-compiling two third party libraries: zlib, a compression library, and openssl, an SSL/TLS and encryption toolkit. The reasons for this choice is that openssl can be compiled to include compression using zlib. This way we can practice building a library that links into another library.

### Toolchain
The cross-compiler: `sudo apt install gcc-arm-linux-gnueabi`
EABI stands for Embedded-Application Binary Interface

